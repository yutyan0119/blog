---
layout: post
author: Yuto Nakamura
tags: [crypto]
description: 
ogp_img:
title: SHA3をRustで実装した
latex: true
---

SHA3をRustで実装した。といっても、SHA3が実装したくて実装したわけではなく、Crystals-Kyberと呼ばれる最新の暗号方式を実装するために、SHA3を実装する必要があったので、正直これに時間を取られるのは不本意っちゃ不本意。SHA3の実装は、[このリポジトリ](https://github.com/yutyan0119/Kyber-rs)に含まれていて、具体的には[`src/sha3.rs`](https://github.com/yutyan0119/Kyber-rs/blob/main/src/sha3.rs)にほとんどの実装がある。

## SHA3
Keccak（ケチャックと読むらしい）というハッシュ関数を用いた新しいハッシュ方式。SHA1, SHA2とは異なるアルゴリズムを採用している。Keccakはあくまでもハッシュ化のアルゴリズムで、SHA3そのものとは異なる。SHA3はKeccakの一部パラメータを固定し、パディングの方法などを変更している。NISTによって、標準化された次世代のハッシュ方式や！って感じがする。[^1] SHA1への攻撃が確立して同じアルゴリズムのSHA2もやばいんちゃうかとなって策定したが、SHA2は今のところ有効（多分ここで言う有効は現実的な時間で収まる）な攻撃手法がなく、まだ使えるらしい。じゃあSHA3を使うメリットってなんやって感じもするが、こっちはこっちで出力長を可変に出来たりするからそういう部分も含めてええんやろうと思う。

## Keccak
KeccakはSHA3の中で使われるハッシュ化アルゴリズム。ハッシュ化とは要するに、任意の長さのデータを取得して、それを内部でビット状態をある一定の操作を施してぐちゃぐちゃにして元のデータがわからないくらいまでぐちゃぐちゃにするということ。一定の操作なので、同じデータに対しては同じ出力が得られなければならない一方で、元に戻せたら怒られるという難しさがある。

**SHA3における**Keccakのアルゴリズムをすごく簡単に言うと、以下のような感じ。

1. データを一定量取得する。以下の操作はデータが取得できなくなるまで繰り返す。
1. データに対して、決まった操作を24回する。
    - θ過程、ρ過程、π過程、χ過程、ι過程の順に操作を行う。それぞれの操作については後述
1. データを取得できなくなったり、一定量に足らなくなったら、最後にパディングを行う。（これはすなわちちょうど一定量取って終わるようなときにもパディングを行うということ）
1. もう一回決まった操作を24回する。
1. 欲しい分だけデータを取得する。（ただし、SHAKEと呼ばれる任意の長さを取得するタイプのものでは、1回でデータが取り切れないこともあるので、取得 -> 24回ぐちゃぐちゃ -> 取得を繰り返すことがある）

これだけ。簡単に見える。

データを取得する過程を吸収過程(absorb)と呼び、データを取得する過程をスクイーズ過程(squeeze)と呼ぶ。これは、Keccak少しずつデータを貯めながら内部でぐちゃぐちゃにし、それを最後に絞り出す構造をスポンジ構造と呼ぶところから来ている。

以下にスポンジ構造の図を示す。

![スポンジ構造の図](https://keccak.team/images/Sponge-150.png)

入力はMでパディングされた後に、一定量ずつ入れられていることがわかる。`r`が入力を受け付けるブロックで`c`はcapacity blockと言われ、入出力には関わらない。この部分は各操作時に一緒に操作される場所である。この`r+c`の部分をKeccakのstateと呼ぶ。入力はstateの`r`の部分とXORすることで入力される。$f$ と書いてあるのは上に示した操作の部分である。

$f$は、Keccakの公式サイトの中で以下のような擬似コードで示されている。

```
Keccak-f[b](A) {
  for i in 0…n-1
    A = Round[b](A, RC[i])
  return A
}

Round[b](A,RC) {
  # θ step
  C[x] = A[x,0] xor A[x,1] xor A[x,2] xor A[x,3] xor A[x,4],   for x in 0…4
  D[x] = C[x-1] xor rot(C[x+1],1),                             for x in 0…4
  A[x,y] = A[x,y] xor D[x],                           for (x,y) in (0…4,0…4)

  # ρ and π steps
  B[y,2*x+3*y] = rot(A[x,y], r[x,y]),                 for (x,y) in (0…4,0…4)

  # χ step
  A[x,y] = B[x,y] xor ((not B[x+1,y]) and B[x+2,y]),  for (x,y) in (0…4,0…4)

  # ι step
  A[0,0] = A[0,0] xor RC

  return A
}
```

ので、言ってしまえばこれをRustで実装してしまえば終わりである。

ちなみに、`r[x,y]`と`RC`は以下のようにして表される。

```rust
const r: [[usize; 5]; 5] = [
    [0, 36, 3, 41, 18],
    [1, 44, 10, 45, 2],
    [62, 6, 43, 15, 61],
    [28, 55, 25, 21, 56],
    [27, 20, 39, 8, 14],
];

const RC: [u64; 24] = [
    0x0000000000000001, 0x0000000000008082, 0x800000000000808a,
    0x8000000080008000, 0x000000000000808b, 0x0000000080000001,
    0x8000000080008081, 0x8000000000008009, 0x000000000000008a,
    0x0000000000000088, 0x0000000080008009, 0x000000008000000a,
    0x000000008000808b, 0x800000000000008b, 0x8000000000008089,
    0x8000000000008003, 0x8000000000008002, 0x8000000000000080,
    0x000000000000800a, 0x800000008000000a, 0x8000000080008081,
    0x8000000000008080, 0x0000000080000001, 0x8000000080008008,
];

```

---
{: data-content="footnotes"}

[^1]: [https://csrc.nist.gov/publications/detail/fips/202/final](https://csrc.nist.gov/publications/detail/fips/202/final)